

\documentclass[10pt,a4paper,twoside]{article}
\usepackage[dutch]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{float,flafter}	
\usepackage{hyperref}
\usepackage{inputenc}
\setlength\paperwidth{20.999cm}\setlength\paperheight{29.699cm}\setlength\voffset{-1in}\setlength\hoffset{-1in}\setlength\topmargin{1cm}\setlength\headheight{12pt}\setlength\headsep{0cm}\setlength\footskip{1.131cm}\setlength\textheight{25cm}\setlength\oddsidemargin{2.499cm}\setlength\textwidth{15.999cm}
\begin{document}
\begin{center}
\vspace{.3cm}
{\bf {\huge Term paper}}
\item
{\bf {\huge ORM in DBMS}}
\vspace{.3cm}
\end{center}
{\bf Name:}  Bhavin Raichura\\
{\bf Roll no:}  19111019 \\
{\bf Subject:}  DBMS\\
{\bf Branch: }  Biomedical Engineering \hspace{\fill}   \\
\hrule

\vspace{.5cm}
\vspace{.4cm}

\renewcommand{\abstractname}{Abstract}

\begin{abstract}
\item One of the challenges of using object-oriented programming (OOP) languages and databases is the complexity of aligning the programming code with database structures. Object-relational mapping (ORM) is a technique that creates a layer between the language and the database, helping programmers work with data without the OOP paradigm.
\item The necessity to learn and code in structured query language (SQL) in order to link their application to a SQL database is a problem for OOP developers.
Data-access code can be written by developers who are familiar with SQL.
Because the developer must extract the data items from the code strings, this raw SQL coding might take a long time.To provide extra information about the data, SQL query builders provide a layer of abstraction to the SQL code. Developers, on the other hand, must be able to read and write SQL.
\item In this term paper I will provide an overview of ORMs, and compare them with SQL tools using an example of an database based application.
\end{abstract}

\item
\item
{\bf {\Large This term paper will highlight the following aspects: }}\\
\begin{itemize}
\end{itemize}
\item 
\begin{enumerate}
\item Introduction
\item Pros of ORM
\item Cons of ORM
\item Conclusion
\item Reference 
\end{enumerate}

\section{Introduction}


\section{Pros of ORM}
\item ORM tools are popular with OOP developers because they minimize the amount of SQL knowledge required to connect a database to an application. ORMs also automatically generate the SQL code, allowing you to focus on generating business logic. There are four significant benefits of using object-related mappers to manage the interface between applications and databases.
\subsection{Productivity}
\item Writing data-access code is time-consuming and doesn’t add a lot of value to the application’s functionality. It’s essentially the plumbing of the code. Using a tool like an ORM that automatically generates the data-access code saves tremendous development time that does not add value to the application. In some cases, the ORM can write 100 percent of the data-access code for the application. The ORM can also help you keep track of database changes making it easier to debug and change the application in the future.
\subsection{Application Design}
\item A well-written ORM will implement design patterns to force you to use best practices for application design. If you use an ORM to manage the data interface, you do not need to create the perfect database schema in advance. You will be able to change the existing interface easily. Separating the database table from the programming code also allows you to switch out data for different applications.
\subsection{Code Reuse}
\item One way to reuse data is to create a class library to generate a separate dynamic-link library (DLL). You can create a new application without needing to duplicate the data-access code.
\subsection{Reduced Testing}
\item Since the code generated by the ORM is well-tested, you do not need to spend as much time testing the data-access code. Instead, you can focus on testing the business logic and code.


\section{Cons of ORM}
\item ORMs are an excellent tool for many applications, but some developers found several drawbacks in using ORMs for data-access applications. The issues seem to correlate with the complexity of the application. With simple applications, having a high-level of abstraction helps the development process. But when the applications are complex, abstraction covers up many details needed to address data-related issues.
\subsection{Performance}
\item A common complaint among OOP developers is the extra code generated by the ORM. The added code slows application performance and makes it harder to maintain. A well-designed ORM should be able to create high-quality code without affecting application speed.
\subsection{Need to Know SQL}
\item High-level abstractions do not always generate the best SQL code, and developers cannot rely on the ORM 100 percent of the time. You still need to know SQL as well as the syntax generated by the ORM.
\subsection{Poor Mapping}
\item ORMs can sometimes create an incorrect mapping between data tables and objects. These problems can cause application problems and be difficult to recognize. ORMs also encourage one-to-one mapping even though it is rare that business applications have many one-to-one relationships.


\section{Conclusion}
Writing SQL code to attach a relational database to an object-oriented application can be a time-consuming activity that generates little value to the business application. Developers can write raw SQL code or use SQL query builders to improve the process, but both methods still require in-depth database knowledge and the ability to code in SQL. ORMs enhance productivity by creating highly-abstract data models and automatically generating SQL code. These tools also make it easier to separate the database from the programming logic giving developers more flexibility. But ORMs have their detractors. Common complaints include reduced performance, extra coding, and poor mapping depending on the ORM quality.


\section{Reference}
\begin{enumerate}
\item https://www.altexsoft.com/blog/object-relational-mapping/
\item 
\end{enumerate}


\end{document}